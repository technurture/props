import mongoose, { Document, Schema } from 'mongoose';
import crypto from 'crypto';

export enum InvoiceStatus {
  PENDING = 'PENDING',
  PAID = 'PAID',
  PARTIALLY_PAID = 'PARTIALLY_PAID',
  CANCELLED = 'CANCELLED'
}

export interface IInvoiceItem {
  description: string;
  quantity: number;
  unitPrice: number;
  total: number;
}

export interface IInsuranceClaim {
  provider?: string;
  claimNumber?: string;
  claimAmount?: number;
  status?: string;
}

export interface IInvoice extends Document {
  invoiceNumber: string;
  patientId: mongoose.Types.ObjectId;
  encounterId?: mongoose.Types.ObjectId;
  branchId: mongoose.Types.ObjectId;
  items: IInvoiceItem[];
  subtotal: number;
  tax: number;
  discount: number;
  grandTotal: number;
  status: InvoiceStatus;
  paymentMethod?: string;
  paidAmount: number;
  balance: number;
  insuranceClaim?: IInsuranceClaim;
  generatedBy: mongoose.Types.ObjectId;
  createdAt: Date;
  updatedAt: Date;
}

const InvoiceItemSchema = new Schema<IInvoiceItem>({
  description: { 
    type: String, 
    required: [true, 'Item description is required'],
    trim: true
  },
  quantity: { 
    type: Number, 
    required: [true, 'Quantity is required'],
    min: [1, 'Quantity must be at least 1']
  },
  unitPrice: { 
    type: Number, 
    required: [true, 'Unit price is required'],
    min: [0, 'Unit price cannot be negative']
  },
  total: { 
    type: Number, 
    required: [true, 'Total is required']
  }
}, { _id: false });

const InsuranceClaimSchema = new Schema<IInsuranceClaim>({
  provider: { type: String },
  claimNumber: { type: String },
  claimAmount: { type: Number },
  status: { type: String }
}, { _id: false });

const InvoiceSchema = new Schema<IInvoice>({
  invoiceNumber: { 
    type: String, 
    required: [true, 'Invoice number is required'],
    unique: true,
    uppercase: true,
    trim: true
  },
  patientId: { 
    type: Schema.Types.ObjectId, 
    ref: 'Patient', 
    required: [true, 'Patient is required']
  },
  encounterId: { 
    type: Schema.Types.ObjectId, 
    ref: 'Encounter',
    unique: true,
    sparse: true
  },
  branchId: { 
    type: Schema.Types.ObjectId, 
    ref: 'Branch', 
    required: [true, 'Branch is required']
  },
  items: {
    type: [InvoiceItemSchema],
    required: [true, 'At least one item is required'],
    validate: {
      validator: function(v: IInvoiceItem[]) {
        return v && v.length > 0;
      },
      message: 'Invoice must have at least one item'
    }
  },
  subtotal: { 
    type: Number, 
    required: [true, 'Subtotal is required'],
    min: [0, 'Subtotal cannot be negative']
  },
  tax: { 
    type: Number, 
    default: 0,
    min: [0, 'Tax cannot be negative']
  },
  discount: { 
    type: Number, 
    default: 0,
    min: [0, 'Discount cannot be negative']
  },
  grandTotal: { 
    type: Number, 
    required: [true, 'Grand total is required'],
    min: [0, 'Grand total cannot be negative']
  },
  status: {
    type: String,
    enum: Object.values(InvoiceStatus),
    default: InvoiceStatus.PENDING
  },
  paymentMethod: { 
    type: String,
    trim: true
  },
  paidAmount: { 
    type: Number, 
    default: 0,
    min: [0, 'Paid amount cannot be negative']
  },
  balance: { 
    type: Number, 
    required: [true, 'Balance is required']
  },
  insuranceClaim: {
    type: InsuranceClaimSchema
  },
  generatedBy: { 
    type: Schema.Types.ObjectId, 
    ref: 'User', 
    required: [true, 'Generated by is required']
  }
}, { timestamps: true });

InvoiceSchema.pre('save', async function(next) {
  if (!this.invoiceNumber) {
    const timestamp = Date.now().toString();
    const randomSuffix = crypto.randomBytes(4).toString('hex').toUpperCase();
    this.invoiceNumber = `INV-${timestamp}-${randomSuffix}`;
  }
  
  this.balance = this.grandTotal - this.paidAmount;
  
  if (this.balance === 0) {
    this.status = InvoiceStatus.PAID;
  } else if (this.paidAmount > 0 && this.balance > 0) {
    this.status = InvoiceStatus.PARTIALLY_PAID;
  }
  
  next();
});

InvoiceSchema.index({ patientId: 1 });
InvoiceSchema.index({ branchId: 1 });
InvoiceSchema.index({ status: 1 });
InvoiceSchema.index({ createdAt: -1 });

export default mongoose.models.Invoice || mongoose.model<IInvoice>('Invoice', InvoiceSchema);
